<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Keepwise — Bulk Prediction</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
  <style>
    .bulk-wrap{max-width:980px;margin:28px auto;padding:20px}
    .bulk-card{background:#fff;border-radius:12px;padding:18px;box-shadow:0 8px 30px rgba(12,18,40,0.06)}
    .hint{color:var(--muted);font-size:13px}
    .progress-outer{background:#f1f5f9;border-radius:8px;height:14px;overflow:hidden;margin-top:8px}
    .progress-inner{height:100%;width:0%;background:linear-gradient(90deg,#0b63ff,#4f9bff);transition:width .3s}
    .controls{display:flex;gap:12px;margin-top:12px;flex-wrap:wrap}
    .small{font-size:13px;color:var(--muted)}
    pre.sample{background:#0f1724;color:#e6edf3;padding:10px;border-radius:8px;overflow:auto}
    @media(max-width:720px){ .controls{flex-direction:column} }
  </style>
</head>
<body>
  <div class="bulk-wrap">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px">
      <div>
        <div style="font-weight:700">Keepwise</div>
        <div style="font-size:13px;color:var(--muted)">Bulk prediction</div>
      </div>
      <div style="display:flex;gap:8px">
        <a class="btn-ghost" href="{{ url_for('dashboard') }}">Back to Dashboard</a>
        <a class="btn-ghost" href="{{ url_for('single') }}">Single Prediction</a>
      </div>
    </div>

    <div class="bulk-card">
      <h3 style="margin-top:0">Bulk CSV prediction</h3>
      <p class="hint">Upload a CSV with one employee per row. The page will send rows to your existing <code>/predict</code> endpoint and collect predictions. No backend changes needed.</p>

      <div style="margin-top:12px">
        <label for="csvFile" style="font-weight:600">Choose CSV file</label>
        <input id="csvFile" type="file" accept=".csv">
        <div class="small" style="margin-top:6px">Make sure your CSV has the required headers:</div>
        <pre class="sample" style="margin-top:8px">
Age,BusinessTravel,Department,MonthlyIncome,OverTime,JobRole,JobSatisfaction,TotalWorkingYears,YearsAtCompany,EnvironmentSatisfaction,WorkLifeBalance,PerformanceRating
30,Travel_Rarely,Sales,7000,Yes,Sales Executive,3,6,2,3,3,3
        </pre>
      </div>

      <div class="controls">
        <button id="startBtn" class="btn-primary" disabled>Start batch</button>
        <button id="cancelBtn" class="btn-ghost" disabled>Cancel</button>
        <a id="downloadLink" class="btn-ghost" style="display:none">Download results</a>
      </div>

      <div style="margin-top:14px">
        <div class="small">Progress</div>
        <div class="progress-outer" aria-hidden="true">
          <div id="progressBar" class="progress-inner" role="progressbar" aria-valuemin="0" aria-valuemax="100"></div>
        </div>
        <div id="progressText" class="small" style="margin-top:6px">No job running</div>
      </div>

      <div style="margin-top:14px" id="resultsArea">
        <!-- results will appear here -->
      </div>

      <hr style="margin-top:18px;border:none;border-top:1px solid #f0f3f7">

      <div class="small" style="margin-top:12px">
        <strong>Notes:</strong>
        <ul style="margin:8px 0 0 18px">
          <li>If you have a server-side batch endpoint, tell me and I will switch this UI to upload the CSV directly to that endpoint (more efficient).</li>
          <li>Large CSVs (thousands of rows) will take longer because this UI posts rows sequentially; consider server-side batch processing for production.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- Bulk uploader script (will provide static/js/bulk_upload.js next) -->
  <script src="{{ url_for('static', filename='js/bulk_upload.js') }}"></script>

  <!--new part with less table columns-->

  <script>
(function(){
  // PUBLIC: call this after uploader finishes (optional)
  window.runBulkCleanup = runCleanup;

  const TABLE_ID = 'bulk-predictions-table'; // keep if you added id to the real table
  const OBSERVE_TIMEOUT = 5000; // ms to wait for table rows to appear before giving up

  // small HTML-escape
  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, function(m){ return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#039;"})[m]; });
  }

  // Remove a column by header text (case-insensitive)
  function removeColumnByHeaderText(tbl, headerText) {
    const ths = tbl.querySelectorAll('thead th');
    let colIndex = -1;
    ths.forEach((th, i) => {
      if (th.textContent.trim().toLowerCase() === headerText.toLowerCase()) colIndex = i;
    });
    if (colIndex === -1) return false;
    const headerRow = tbl.querySelector('thead tr');
    if (headerRow && headerRow.children[colIndex]) headerRow.children[colIndex].remove();
    tbl.querySelectorAll('tbody tr').forEach(row => {
      if (row.children[colIndex]) row.children[colIndex].remove();
    });
    return true;
  }

  // Run a function on each tbody cell in a given column index
  function forEachCellInColumn(tbl, colIndex, fn) {
    tbl.querySelectorAll('tbody tr').forEach(row => {
      const cell = row.children[colIndex];
      if (cell) fn(cell);
    });
  }

  // Convert raw cell content into friendly label
  function convertRawCellContentToLabel(cell) {
    if (!cell) return;
    const raw = (cell.textContent || cell.innerText || '').trim();
    const normalized = raw.replace(/\s+/g, ' ').trim();

    // 1) JSON "prediction": 1/0
    const predMatch = raw.match(/"prediction"\s*[:=]\s*([01])/i) || raw.match(/prediction["']?\s*[:=]\s*([01])/i);
    if (predMatch) {
      const p = Number(predMatch[1]);
      cell.innerHTML = p === 1 ? '<strong>Employee is likely to leave</strong>' : '<strong>Employee is likely to stay</strong>';
      return;
    }

    // 2) probability field
    const probMatch = raw.match(/"probability"\s*[:=]\s*([0-9]*\.?[0-9]+)/i) || raw.match(/probability[:\s]*([0-9]*\.?[0-9]+)/i);
    if (probMatch) {
      const prob = parseFloat(probMatch[1]);
      if (!isNaN(prob)) {
        cell.innerHTML = (prob > 0.5)
          ? `<strong>Employee is likely to leave</strong> • ${prob.toFixed(3)}`
          : `<strong>Employee is likely to stay</strong> • ${prob.toFixed(3)}`;
        return;
      }
    }

    // 3) HTML phrase detection
    if (/Employee\s+is\s+likely\s+to\s+leave/i.test(raw) || /likely to leave/i.test(normalized)) {
      const prob2 = (raw.match(/Probability[:\s]*([0-9]*\.?[0-9]+)/i) || [])[1];
      cell.innerHTML = `<strong>Employee is likely to leave</strong>${prob2 ? ' • ' + parseFloat(prob2).toFixed(3) : ''}`;
      return;
    }
    if (/Employee\s+is\s+likely\s+to\s+stay/i.test(raw) || /likely to stay/i.test(normalized)) {
      const prob2 = (raw.match(/Probability[:\s]*([0-9]*\.?[0-9]+)/i) || [])[1];
      cell.innerHTML = `<strong>Employee is likely to stay</strong>${prob2 ? ' • ' + parseFloat(prob2).toFixed(3) : ''}`;
      return;
    }

    // 4) any probability pattern like 0.600
    const anyProb = raw.match(/([01]\.\d{1,4})/);
    if (anyProb) {
      const p = parseFloat(anyProb[1]);
      if (!isNaN(p)) {
        cell.innerHTML = (p > 0.5)
          ? `<strong>Employee is likely to leave</strong> • ${p.toFixed(3)}`
          : `<strong>Employee is likely to stay</strong> • ${p.toFixed(3)}`;
        return;
      }
    }

    // 5) fallback: look for explicit 1 or 0 tokens
    if (/\b"1"\b/.test(raw) || /\bprediction\s*[:=]\s*1\b/i.test(raw) || /\b\sprediction\s+1\b/i.test(raw)) {
      cell.innerHTML = '<strong>Employee is likely to leave</strong>';
      return;
    }
    if (/\b"0"\b/.test(raw) || /\bprediction\s*[:=]\s*0\b/i.test(raw) || /\b\sprediction\s+0\b/i.test(raw)) {
      cell.innerHTML = '<strong>Employee is likely to stay</strong>';
      return;
    }

    // 6) ultimate fallback: show a short preview (safe)
    const preview = normalized.length > 120 ? normalized.slice(0,120) + '…' : normalized;
    cell.innerHTML = `<em>${escapeHtml(preview)}</em>`;
  }

  // Try to detect raw column index and run converter
  function transformTableOnce(tbl) {
    if (!tbl) return false;
    const thead = tbl.querySelector('thead');
    const tbody = tbl.querySelector('tbody');
    if (!thead || !tbody) return false;

    const headerCells = Array.from(thead.querySelectorAll('th'));
    const headers = headerCells.map(h => h.textContent.trim().toLowerCase());

    // remove error column
    if (headers.includes('error')) {
      removeColumnByHeaderText(tbl, 'error');
    }

    // re-evaluate headers after possible removal
    const updatedHeaders = Array.from(tbl.querySelectorAll('thead th')).map(h => h.textContent.trim().toLowerCase());
    let rawIdx = updatedHeaders.indexOf('raw');

    if (rawIdx === -1) {
      // try partial match
      rawIdx = updatedHeaders.findIndex(h => h.includes('raw'));
    }

    if (rawIdx !== -1) {
      forEachCellInColumn(tbl, rawIdx, convertRawCellContentToLabel);
      return true;
    }

    // If no header named raw, try to detect candidate cells (long raw dumps)
    let anyTransformed = false;
    tbody.querySelectorAll('tr').forEach(row => {
      for (let i = 0; i < row.children.length; i++) {
        const text = (row.children[i].textContent || '').trim();
        if (/\<\!doctype|\{["']prediction["']|Probability[:\s]/i.test(text)) {
          convertRawCellContentToLabel(row.children[i]);
          anyTransformed = true;
          break;
        }
      }
    });
    return anyTransformed;
  }

  // MAIN: try to find the actual table used by the uploader
  function findTable() {
    // 1) prefer ID if present
    let tbl = document.getElementById(TABLE_ID);
    if (tbl) return tbl;
    // 2) else try to find a table with header containing "prediction" and "raw"
    const candidates = Array.from(document.querySelectorAll('table'));
    for (const t of candidates) {
      const head = t.querySelectorAll('thead th');
      if (!head.length) continue;
      const headText = Array.from(head).map(h => h.textContent.toLowerCase()).join('|');
      if (headText.includes('prediction') && headText.includes('raw')) return t;
    }
    // 3) else return first table with tbody rows
    const withRows = candidates.find(t => t.querySelectorAll('tbody tr').length > 0);
    return withRows || candidates[0] || null;
  }

  // run cleanup with observer (handles dynamic row insertion)
  function runCleanup() {
    const tbl = findTable();
    if (!tbl) {
      console.warn('Bulk cleanup: no table found on page.');
      return;
    }

    // If table already has rows and transform succeeds, done.
    if (transformTableOnce(tbl)) return;

    // Otherwise observe tbody for added rows for a short while
    let observed = false;
    const tbody = tbl.querySelector('tbody') || (function(){ // try to create tbody if missing
      const b = document.createElement('tbody');
      tbl.appendChild(b);
      return b;
    })();

    const observer = new MutationObserver((mutations, obs) => {
      // if any rows added, attempt transform
      const hasRows = tbody.querySelectorAll('tr').length > 0;
      if (hasRows) {
        if (transformTableOnce(tbl)) {
          observed = true;
          obs.disconnect();
        }
      }
    });

    observer.observe(tbody, { childList: true, subtree: false });

    // safety timeout: stop observing after OBSERVE_TIMEOUT ms
    setTimeout(() => {
      if (!observed) {
        observer.disconnect();
        // try one last time
        transformTableOnce(tbl);
      }
    }, OBSERVE_TIMEOUT);
  }

  // Auto-run once on DOMContentLoaded (safe)
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', runCleanup);
  } else {
    // already loaded: run after small delay to let other scripts initialize
    setTimeout(runCleanup, 300);
  }

  // expose for manual trigger (uploader can call this)
  window.runBulkCleanup = runCleanup;
})();
</script>

</body>
</html>
